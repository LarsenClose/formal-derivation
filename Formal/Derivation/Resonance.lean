/-
  Resonance — Efflux Propagation Between Coherent Objects

  Formalizes:
    - Resonance is how efflux propagates between coherent actual objects
    - Coherent structures radiate computational surplus
    - That surplus propagates via resonance

  Key structures:
    CoherentObject  — actual object with achieved internal stability
    ComputationalSurplus — MDL-differential generated by a coherent structure
    Efflux          — structured emission that carries computational surplus
    Resonance       — the propagation relation between coherent objects

  Connection to GroundState.Radiation (A5): A5 establishes that terminal
  crystals radiate constraint as presheaves. Here we formalize *what* they
  radiate (computational surplus) and *how* it propagates (via resonance
  between coherent objects, not broadcast into an undifferentiated field).
-/

import Mathlib.Data.Nat.Basic
import Mathlib.Order.Basic

namespace Resonance

/-!
## Coherent Objects

A coherent actual object has achieved internal stability: its states
are self-consistent and its dynamics preserve that consistency. Coherence
is the precondition for radiation — only coherent objects emit efflux.
-/

/-- A coherent actual object: a type of states with a coherence predicate,
    continuous dynamics, and at least one coherent state. Coherence is
    internal self-consistency — the object's dynamics close on themselves. -/
structure CoherentObject where
  /-- The space of possible states -/
  State : Type
  /-- Coherence predicate: which states are internally consistent -/
  coherent : State → Prop
  /-- At least one coherent state exists -/
  hasCoherent : ∃ s, coherent s
  /-- State dynamics: one-step evolution -/
  evolve : State → State
  /-- Coherence is invariant: coherent states remain coherent under dynamics -/
  coherenceStable : ∀ s, coherent s → coherent (evolve s)

/-!
## Computational Surplus

Computational surplus is the MDL-differential excess: the positive difference
between the cost of extensional enumeration (storing all instances) and the
cost of intensional generation (storing a generator plus per-instance
encoding costs). A coherent structure generating the same pattern repeatedly
accumulates surplus — it is doing more work than necessary via enumeration.
-/

/-- Computational surplus: the MDL-differential generated by a coherent structure.
    Surplus exists when the intensional description (generator + encodings)
    is strictly smaller than the extensional description (all instances). -/
structure ComputationalSurplus where
  /-- Number of instances computed -/
  numInstances : ℕ
  /-- Average size of each instance (in description-length units) -/
  instanceSize : ℕ
  /-- Size of the generator -/
  generatorSize : ℕ
  /-- Total per-instance encoding cost given the generator -/
  totalEncodingCost : ℕ
  /-- Surplus condition: intensional cost is strictly less than extensional cost -/
  surplusExists : generatorSize + totalEncodingCost < numInstances * instanceSize

/-- The surplus amount: how much compression is achieved -/
def ComputationalSurplus.amount (cs : ComputationalSurplus) : ℕ :=
  cs.numInstances * cs.instanceSize - (cs.generatorSize + cs.totalEncodingCost)

/-- Computational surplus is always strictly positive when it exists -/
theorem surplus_positive (cs : ComputationalSurplus) : 0 < cs.amount := by
  unfold ComputationalSurplus.amount
  exact Nat.sub_pos_of_lt cs.surplusExists

/-!
## Efflux

Efflux is the structured emission of a coherent object. It is not raw
output but *surplus* — the excess generated beyond what is needed to
maintain internal coherence. When a coherent object is in a coherent state,
it emits. The emission carries the object's computational surplus.
-/

/-- Efflux: what a coherent object radiates.
    Each efflux carries a computational surplus (the compressed structure)
    and an emission type (the actual radiated content). Coherent states
    always produce nonempty emissions — coherence is the enabling condition. -/
structure Efflux (A : CoherentObject) where
  /-- The type of emitted content -/
  Emission : Type
  /-- Coherent states emit: every coherent state produces an emission -/
  emits : ∀ s, A.coherent s → Nonempty Emission
  /-- The efflux carries computational surplus: emission is compressed structure,
      not raw enumeration -/
  surplus : ComputationalSurplus
  /-- Different coherent states can produce different emissions -/
  stateReflected : ∃ (s₁ s₂ : A.State), A.coherent s₁ ∧ A.coherent s₂ ∧ s₁ ≠ s₂

/-- Coherent structures radiate computational surplus:
    the efflux of any coherent object carries strictly positive surplus -/
theorem efflux_carries_surplus (A : CoherentObject) (ef : Efflux A) :
    0 < ef.surplus.amount :=
  surplus_positive ef.surplus

/-- Any coherent object with efflux emits when in a coherent state -/
theorem efflux_requires_coherence (A : CoherentObject) (ef : Efflux A) :
    (∃ s, A.coherent s) → ∃ _ : ef.Emission, True := by
  intro ⟨s, hs⟩
  obtain ⟨e⟩ := ef.emits s hs
  exact ⟨e, trivial⟩

/-!
## Resonance

Resonance is the propagation relation between coherent objects. A's efflux
reaches B when:
  1. B can receive A's emissions (reception)
  2. Reception of A's coherent emission lands in a coherent B-state
     (coherence transmission — the structure is preserved, not destroyed)

Resonance is selective: it requires structural matching between A and B.
Non-coherent objects absorb without preserving the structure.
-/

/-- A resonance channel between coherent objects A and B:
    A's efflux propagates to B with coherence preservation.
    B is a *resonant receiver* — it receives A's emission in a way that
    maintains B's own coherence, enabling B to in turn emit. -/
structure Channel (A B : CoherentObject) where
  /-- The efflux from A that propagates to B -/
  efflux : Efflux A
  /-- Reception map: A's emissions are received as B-states -/
  receive : efflux.Emission → B.State
  /-- Coherence transmission: receiving a coherent emission preserves B's coherence.
      This is the defining property of resonance vs mere absorption. -/
  coherenceTransmission : ∀ (s : A.State), A.coherent s →
    ∃ e : efflux.Emission, B.coherent (receive e)

/-!
## Propagation Theorems

The key results: surplus propagates between coherent objects via resonance,
and this propagation forms a chain.
-/

/-- Resonance propagates coherence: if A is coherent and resonates with B,
    then B achieves a coherent state through the received efflux -/
theorem resonance_propagates (A B : CoherentObject) (r : Channel A B) :
    (∃ s, A.coherent s) → ∃ bs : B.State, B.coherent bs := by
  intro ⟨s, hs⟩
  obtain ⟨e, hcoherent⟩ := r.coherenceTransmission s hs
  exact ⟨r.receive e, hcoherent⟩

/-- Surplus propagates via resonance: A's computational surplus reaches B.
    This is the central claim: efflux *carries* surplus and resonance *delivers* it. -/
theorem surplus_propagates_via_resonance (A B : CoherentObject) (r : Channel A B) :
    (∃ s, A.coherent s) →
    0 < r.efflux.surplus.amount ∧ ∃ bs : B.State, B.coherent bs := fun hA =>
  ⟨efflux_carries_surplus A r.efflux, resonance_propagates A B r hA⟩

/-- Resonance is transitive: A's efflux can reach C via B.
    If A resonates with B and B resonates with C, A's surplus propagates to C. -/
theorem resonance_transitive (A B C : CoherentObject)
    (rAB : Channel A B) (rBC : Channel B C) :
    (∃ s, A.coherent s) → ∃ cs : C.State, C.coherent cs := by
  intro hA
  exact resonance_propagates B C rBC (resonance_propagates A B rAB hA)

/-- A chain of resonating objects propagates surplus all the way through:
    given a sequence of pairwise resonating coherent objects, coherence
    (and hence surplus) reaches the final object from any coherent initial state. -/
theorem resonance_chain_propagates
    (A B C D : CoherentObject)
    (rAB : Channel A B) (rBC : Channel B C) (rCD : Channel C D) :
    (∃ s, A.coherent s) → ∃ ds : D.State, D.coherent ds := by
  intro hA
  have hB := resonance_propagates A B rAB hA
  have hC := resonance_propagates B C rBC hB
  exact resonance_propagates C D rCD hC

/-- Coherence is a stable ground for efflux: dynamics preserve it,
    so a coherent object continues to emit across time steps. -/
theorem coherence_enables_ongoing_efflux (A : CoherentObject) :
    (∃ s, A.coherent s) → ∃ s, A.coherent (A.evolve s) := by
  intro ⟨s, hs⟩
  exact ⟨s, A.coherenceStable s hs⟩

end Resonance
